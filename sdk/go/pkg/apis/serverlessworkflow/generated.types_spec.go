// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1alpha2

import "fmt"
import "encoding/json"
import "reflect"
import "k8s.io/apimachinery/pkg/runtime"

type Action struct {
	// ActionDataFilter corresponds to the JSON schema field "actionDataFilter".
	ActionDataFilter *Actiondatafilter `json:"actionDataFilter,omitempty"`

	// References a reusable function definition
	FunctionRef Functionref `json:"functionRef"`

	// Unique action definition name
	Name *string `json:"name,omitempty"`

	// Time period to wait for function execution to complete
	Timeout *string `json:"timeout,omitempty"`
}

type Actiondatafilter struct {
	// JSONPath definition that selects parts of the states data input to be the
	// action data
	DataInputPath *string `json:"dataInputPath,omitempty"`

	// JSONPath definition that selects parts of the actions data result, to be merged
	// with the states data
	DataResultsPath *string `json:"dataResultsPath,omitempty"`
}

// Branch Definition
type Branch struct {
	// Branch name
	Name string `json:"name"`

	// State Definitions
	// +kubebuilder:pruning:PreserveUnknownFields
	States []runtime.RawExtension `json:"states"`
}

// This state performs an action, then waits for the callback event that denotes
// completion of the action
type Callbackstate struct {
	// Defines the action to be executed
	Action *Action `json:"action,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Callback event data filter definition
	EventDataFilter *Eventdatafilter `json:"eventDataFilter,omitempty"`

	// References an unique callback event name in the defined workflow events
	EventRef *string `json:"eventRef,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// States retry definitions
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// State data filter definition
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Time period to wait for incoming events (ISO 8601 format)
	Timeout *string `json:"timeout,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *CallbackstateType `json:"type,omitempty"`
}

type CallbackstateType string

const CallbackstateTypeCallback CallbackstateType = "callback"

// Serverless Workflow is a vendor-neutral specification for defining the model of
// workflows responsible for orchestrating event-driven serverless applications
// +kubebuilder:pruning:PreserveUnknownFields
type Common runtime.RawExtension

// Permits transitions to other states based on data conditions
type Databasedswitch struct {
	// Defines conditions evaluated against state data
	DataConditions []Datacondition `json:"dataConditions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Next transition of the workflow if there is no matching data conditions, or
	// event timeout is reached
	Default *Transition `json:"default,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// State type
	Type *DatabasedswitchType `json:"type,omitempty"`
}

type DatabasedswitchType string

const DatabasedswitchTypeSwitch DatabasedswitchType = "switch"

// Switch state data based condition
type Datacondition struct {
	// Condition operator
	Operator DataconditionOperator `json:"operator"`

	// JSONPath expression that selects elements of state data
	Path string `json:"path"`

	// Next transition of the workflow if there is valid matches
	Transition Transition `json:"transition"`

	// Matching value
	Value string `json:"value"`
}

type DataconditionOperator string

const DataconditionOperatorCustom DataconditionOperator = "custom"
const DataconditionOperatorEquals DataconditionOperator = "equals"
const DataconditionOperatorExists DataconditionOperator = "exists"
const DataconditionOperatorGreaterthan DataconditionOperator = "greaterthan"
const DataconditionOperatorGreaterthanorequals DataconditionOperator = "greaterthanorequals"
const DataconditionOperatorLessthan DataconditionOperator = "lessthan"
const DataconditionOperatorLessthanorequals DataconditionOperator = "lessthanorequals"
const DataconditionOperatorMatches DataconditionOperator = "matches"
const DataconditionOperatorNotequals DataconditionOperator = "notequals"
const DataconditionOperatorNotexists DataconditionOperator = "notexists"
const DataconditionOperatorNotmatches DataconditionOperator = "notmatches"
const DataconditionOperatorNotnull DataconditionOperator = "notnull"
const DataconditionOperatorNull DataconditionOperator = "null"

// Causes the workflow execution to delay for a specified duration
type Delaystate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// OnError Definition
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Amount of time (ISO 8601 format) to delay
	TimeDelay *string `json:"timeDelay,omitempty"`

	// Next transition of the workflow after the time delay
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *DelaystateType `json:"type,omitempty"`
}

type DelaystateType string

const DelaystateTypeDelay DelaystateType = "delay"

// State end definition
type End struct {
	// Kind of end definition
	Kind *EndKind `json:"kind,omitempty"`

	// If end kind is event, select one of the defined events by name and set its data
	ProduceEvent *Produceevent `json:"produceEvent,omitempty"`
}

type EndKind string

const EndKindDefault EndKind = "default"
const EndKindEvent EndKind = "event"
const EndKindTerminate EndKind = "terminate"

type Error struct {
	// ErrorDataFilter corresponds to the JSON schema field "errorDataFilter".
	ErrorDataFilter *Errordatafilter `json:"errorDataFilter,omitempty"`

	// Expression that matches against the error in the state data input
	Expression Expression `json:"expression"`

	// Next transition of the workflow when expression is matched
	Transition Transition `json:"transition"`
}

type Errordatafilter struct {
	// JSONPath definition that selects parts of the error data, to be merged with the
	// states data
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

type Eventactions struct {
	// Specifies how actions are to be performed (in sequence of parallel)
	ActionMode EventactionsActionMode `json:"actionMode,omitempty"`

	// Actions to be performed if expression matches
	Actions []Action `json:"actions"`

	// EventDataFilter corresponds to the JSON schema field "eventDataFilter".
	EventDataFilter *Eventdatafilter `json:"eventDataFilter,omitempty"`

	// References one or more unique event names in the defined workflow events
	EventRefs []string `json:"eventRefs"`
}

type EventactionsActionMode string

const EventactionsActionModeParallel EventactionsActionMode = "parallel"
const EventactionsActionModeSequential EventactionsActionMode = "sequential"

// Permits transitions to other states based on events
type Eventbasedswitch struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Next transition of the workflow if there is no matching data conditions, or
	// event timeout is reached
	Default *Transition `json:"default,omitempty"`

	// Defines conditions evaluated against events
	EventConditions []Eventcondition `json:"eventConditions,omitempty"`

	// If eventConditions is used, defines the time period to wait for events (ISO
	// 8601 format)
	EventTimeout *string `json:"eventTimeout,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// State type
	Type *EventbasedswitchType `json:"type,omitempty"`
}

type EventbasedswitchType string

const EventbasedswitchTypeSwitch EventbasedswitchType = "switch"

// Switch state data event condition
type Eventcondition struct {
	// References an unique event name in the defined workflow events
	EventRef string `json:"eventRef"`

	// Next transition of the workflow if there is valid matches
	Transition Transition `json:"transition"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CallbackstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CallbackstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CallbackstateType, v)
	}
	*j = CallbackstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventstateType, v)
	}
	*j = EventstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DataconditionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DataconditionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DataconditionOperator, v)
	}
	*j = DataconditionOperator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Eventstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["exclusive"]; !ok || v == nil {
		plain.Exclusive = true
	}
	*j = Eventstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Schedule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["interval"]; !ok || v == nil {
		return fmt.Errorf("field interval: required")
	}
	type Plain Schedule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Schedule(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForeachstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ForeachstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ForeachstateType, v)
	}
	*j = ForeachstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Foreachstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Foreachstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["max"]; !ok || v == nil {
		plain.Max = 0
	}
	*j = Foreachstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InjectstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_InjectstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_InjectstateType, v)
	}
	*j = InjectstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StartKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StartKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StartKind, v)
	}
	*j = StartKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationstateActionMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OperationstateActionMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OperationstateActionMode, v)
	}
	*j = OperationstateActionMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OperationstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OperationstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OperationstateType, v)
	}
	*j = OperationstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Retry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["expression"]; !ok || v == nil {
		return fmt.Errorf("field expression: required")
	}
	type Plain Retry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["maxAttempts"]; !ok || v == nil {
		plain.MaxAttempts = 1
	}
	*j = Retry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Operationstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Operationstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["actionMode"]; !ok || v == nil {
		plain.ActionMode = "sequential"
	}
	*j = Operationstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Error) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["expression"]; !ok || v == nil {
		return fmt.Errorf("field expression: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	type Plain Error
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Error(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["nextState"]; !ok || v == nil {
		return fmt.Errorf("field nextState: required")
	}
	type Plain Transition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Transition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParallelstateCompletionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ParallelstateCompletionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParallelstateCompletionType, v)
	}
	*j = ParallelstateCompletionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Expression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["body"]; !ok || v == nil {
		return fmt.Errorf("field body: required")
	}
	type Plain Expression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Expression(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Datacondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["operator"]; !ok || v == nil {
		return fmt.Errorf("field operator: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain Datacondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Datacondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParallelstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ParallelstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ParallelstateType, v)
	}
	*j = ParallelstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventbasedswitchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventbasedswitchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventbasedswitchType, v)
	}
	*j = EventbasedswitchType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DatabasedswitchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DatabasedswitchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DatabasedswitchType, v)
	}
	*j = DatabasedswitchType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Parallelstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Parallelstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["completionType"]; !ok || v == nil {
		plain.CompletionType = "and"
	}
	if v, ok := raw["n"]; !ok || v == nil {
		plain.N = 0
	}
	*j = Parallelstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Produceevent) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	type Plain Produceevent
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Produceevent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SubflowstateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SubflowstateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SubflowstateType, v)
	}
	*j = SubflowstateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EndKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EndKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EndKind, v)
	}
	*j = EndKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DelaystateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DelaystateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DelaystateType, v)
	}
	*j = DelaystateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Subflowstate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Subflowstate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["waitForCompletion"]; !ok || v == nil {
		plain.WaitForCompletion = false
	}
	*j = Subflowstate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Branch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["states"]; !ok || v == nil {
		return fmt.Errorf("field states: required")
	}
	type Plain Branch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Branch(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Action) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["functionRef"]; !ok || v == nil {
		return fmt.Errorf("field functionRef: required")
	}
	type Plain Action
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Action(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventcondition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventRef"]; !ok || v == nil {
		return fmt.Errorf("field eventRef: required")
	}
	if v, ok := raw["transition"]; !ok || v == nil {
		return fmt.Errorf("field transition: required")
	}
	type Plain Eventcondition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Eventcondition(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventactionsActionMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventactionsActionMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventactionsActionMode, v)
	}
	*j = EventactionsActionMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Functionref) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["refName"]; !ok || v == nil {
		return fmt.Errorf("field refName: required")
	}
	type Plain Functionref
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Functionref(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventdef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["source"]; !ok || v == nil {
		return fmt.Errorf("field source: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Eventdef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Eventdef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Function) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["resource"]; !ok || v == nil {
		return fmt.Errorf("field resource: required")
	}
	type Plain Function
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Function(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Eventactions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["actions"]; !ok || v == nil {
		return fmt.Errorf("field actions: required")
	}
	if v, ok := raw["eventRefs"]; !ok || v == nil {
		return fmt.Errorf("field eventRefs: required")
	}
	type Plain Eventactions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["actionMode"]; !ok || v == nil {
		plain.ActionMode = "sequential"
	}
	*j = Eventactions(plain)
	return nil
}

type Eventdatafilter struct {
	// JSONPath definition that selects parts of the event data, to be merged with the
	// states data
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

type Eventdef struct {
	// Context attribute name of the CloudEvent which value is to be used for event
	// correlation
	CorrelationToken *string `json:"correlationToken,omitempty"`

	// Metadata information
	Metadata Metadata `json:"metadata,omitempty"`

	// Unique event name
	Name string `json:"name"`

	// CloudEvent source
	Source string `json:"source"`

	// CloudEvent type
	Type string `json:"type"`
}

// Workflow event definitions. Defines events that can be consumed or produced
type Events []Eventdef

// This state is used to wait for events from event sources, then consumes them and
// invoke one or more actions to run in sequence or parallel
type Eventstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Define what events trigger one or more actions to be performed
	EventsActions []Eventactions `json:"eventsActions,omitempty"`

	// If true consuming one of the defined events causes its associated actions to be
	// performed. If false all of the defined events must be consumed in order for
	// actions to be performed
	Exclusive bool `json:"exclusive,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Time period to wait for incoming events (ISO 8601 format)
	Timeout *string `json:"timeout,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *EventstateType `json:"type,omitempty"`
}

type EventstateType string

const EventstateTypeEvent EventstateType = "event"

// Defines the expression language and body of the expression
type Expression struct {
	// The expression body
	Body string `json:"body"`

	// Expression language. For example 'spel', 'jexl', 'cel', etc
	Language *string `json:"language,omitempty"`
}

// Execute a set of defined states for each element of the data input array
type Foreachstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// JSONPath expression selecting a JSON array element of the states data input
	InputCollection *string `json:"inputCollection,omitempty"`

	// JSONPath expression specifying a JSON object field of the states data input.
	// For each parallel iteration, this field will get populated with a unique
	// element of the inputCollection array
	InputParameter *string `json:"inputParameter,omitempty"`

	// Specifies how upper bound on how many iterations may run in parallel
	Max int `json:"max,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// JSONPath expression specifying where in the states data output to place the
	// final data output of each iteration of the executed states
	OutputCollection *string `json:"outputCollection,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// States to be executed for each of the elements of inputCollection
	// +kubebuilder:pruning:PreserveUnknownFields
	States []runtime.RawExtension `json:"states,omitempty"`

	// Amount of time (ISO 8601 format) to wait between each iteration
	TimeDelay *string `json:"timeDelay,omitempty"`

	// Next transition of the workflow after state has completed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *ForeachstateType `json:"type,omitempty"`
}

type ForeachstateType string

const ForeachstateTypeForeach ForeachstateType = "foreach"

type Function struct {
	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// Unique function name
	Name string `json:"name"`

	// Function resource (URI)
	Resource string `json:"resource"`

	// Function type
	Type *string `json:"type,omitempty"`
}

// Function Reference
type Functionref struct {
	// Function parameters
	Parameters FunctionrefParameters `json:"parameters,omitempty"`

	// Name of the referenced function
	RefName string `json:"refName"`
}

// Function parameters
// +kubebuilder:pruning:PreserveUnknownFields
type FunctionrefParameters runtime.RawExtension

// Workflow function definitions
type Functions []Function

// Inject static data into state data. Does not perform any actions
type Injectstate struct {
	// JSON object which can be set as states data input and can be manipulated via
	// filters
	Data InjectstateData `json:"data,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after subflow has completed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *InjectstateType `json:"type,omitempty"`
}

// JSON object which can be set as states data input and can be manipulated via
// filters
// +kubebuilder:pruning:PreserveUnknownFields
type InjectstateData runtime.RawExtension

type InjectstateType string

const InjectstateTypeInject InjectstateType = "inject"

// Metadata information
type Metadata map[string]string

// Defines actions be performed. Does not wait for incoming events
type Operationstate struct {
	// Specifies whether actions are performed in sequence or in parallel
	ActionMode OperationstateActionMode `json:"actionMode,omitempty"`

	// Actions to be performed
	Actions []Action `json:"actions,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after all the actions have been performed
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *OperationstateType `json:"type,omitempty"`
}

type OperationstateActionMode string

const OperationstateActionModeParallel OperationstateActionMode = "parallel"
const OperationstateActionModeSequential OperationstateActionMode = "sequential"

type OperationstateType string

const OperationstateTypeOperation OperationstateType = "operation"

// Consists of a number of states that are executed in parallel
type Parallelstate struct {
	// Branch Definitions
	Branches []Branch `json:"branches,omitempty"`

	// Option types on how to complete branch execution.
	CompletionType ParallelstateCompletionType `json:"completionType,omitempty"`

	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique State id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// Used when completionType is set to 'n_of_m' to specify the 'N' value
	N int `json:"n,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// Retry Definition
	Retry []Retry `json:"retry,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after all branches have completed execution
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *ParallelstateType `json:"type,omitempty"`
}

type ParallelstateCompletionType string

const ParallelstateCompletionTypeAnd ParallelstateCompletionType = "and"
const ParallelstateCompletionTypeNOfM ParallelstateCompletionType = "n_of_m"
const ParallelstateCompletionTypeXor ParallelstateCompletionType = "xor"

type ParallelstateType string

const ParallelstateTypeParallel ParallelstateType = "parallel"

// Produce an event and set its data
type Produceevent struct {
	// If String, JSONPath expression which selects parts of the states data output to
	// become the data of the produced event. If object a custom object to become the
	// data of produced event.
	// +kubebuilder:pruning:PreserveUnknownFields
	Data runtime.RawExtension `json:"data,omitempty"`

	// References a name of a defined event
	EventRef string `json:"eventRef"`
}

// Retry Definition
type Retry struct {
	// Expression that matches against state data output
	Expression Expression `json:"expression"`

	// Interval value for retry (ISO 8601 repeatable format)
	Interval *string `json:"interval,omitempty"`

	// Maximum number of retry attempts (1 by default). Value of 0 means no retries
	// are performed
	MaxAttempts int `json:"maxAttempts,omitempty"`

	// Multiplier value by which interval increases during each attempt (ISO 8601 time
	// format)
	Multiplier *string `json:"multiplier,omitempty"`
}

// Start state schedule definition
type Schedule struct {
	// Time interval describing when the workflow starting state is active
	Interval string `json:"interval"`
}

// State start definition
type Start struct {
	// Kind of start definition
	Kind *StartKind `json:"kind,omitempty"`

	// If kind is scheduled, define when the starting state is or becomes active
	Schedule *Schedule `json:"schedule,omitempty"`
}

type StartKind string

const StartKindDefault StartKind = "default"
const StartKindScheduled StartKind = "scheduled"

type Statedatafilter struct {
	// JSONPath definition that selects parts of the states data input
	DataInputPath *string `json:"dataInputPath,omitempty"`

	// JSONPath definition that selects parts of the states data output
	DataOutputPath *string `json:"dataOutputPath,omitempty"`
}

// Defines a sub-workflow to be executed
type Subflowstate struct {
	// URI to JSON Schema that state data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that state data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// State end definition
	End *End `json:"end,omitempty"`

	// Unique state id
	Id *string `json:"id,omitempty"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// State name
	Name *string `json:"name,omitempty"`

	// States error handling definitions
	OnError []Error `json:"onError,omitempty"`

	// State start definition
	Start *Start `json:"start,omitempty"`

	// StateDataFilter corresponds to the JSON schema field "stateDataFilter".
	StateDataFilter *Statedatafilter `json:"stateDataFilter,omitempty"`

	// Next transition of the workflow after SubFlow has completed execution
	Transition *Transition `json:"transition,omitempty"`

	// State type
	Type *SubflowstateType `json:"type,omitempty"`

	// Workflow execution must wait for sub-workflow to finish before continuing
	WaitForCompletion bool `json:"waitForCompletion,omitempty"`

	// Sub-workflow unique id
	WorkflowId *string `json:"workflowId,omitempty"`
}

type SubflowstateType string

const SubflowstateTypeSubflow SubflowstateType = "subflow"

// +kubebuilder:pruning:PreserveUnknownFields
type Switchstate runtime.RawExtension

type Transition struct {
	// Expression evaluated against state's data output. Must evaluate to true for the
	// transition to be valid
	Expression *Expression `json:"expression,omitempty"`

	// Name of state to transition to
	NextState string `json:"nextState"`

	// Reference one of the defined events by name and set its data
	ProduceEvent *Produceevent `json:"produceEvent,omitempty"`
}

// Serverless Workflow is a vendor-neutral specification for defining the model of
// workflows responsible for orchestrating event-driven serverless applications
type Workflow struct {
	// URI to JSON Schema that workflow data input adheres to
	DataInputSchema *string `json:"dataInputSchema,omitempty"`

	// URI to JSON Schema that workflow data output adheres to
	DataOutputSchema *string `json:"dataOutputSchema,omitempty"`

	// Workflow description
	Description *string `json:"description,omitempty"`

	// Events corresponds to the JSON schema field "events".
	Events Events `json:"events,omitempty"`

	// Default expression language to be used throughout the workflow definition
	ExpressionLanguage *string `json:"expressionLanguage,omitempty"`

	// Workflow extensions
	// +kubebuilder:pruning:PreserveUnknownFields
	Extensions []runtime.RawExtension `json:"extensions,omitempty"`

	// Functions corresponds to the JSON schema field "functions".
	Functions Functions `json:"functions,omitempty"`

	// Workflow unique identifier
	Id string `json:"id"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata,omitempty"`

	// Workflow name
	Name string `json:"name"`

	// Serverless Workflow schema version
	SchemaVersion *string `json:"schemaVersion,omitempty"`

	// State definitions
	// +kubebuilder:pruning:PreserveUnknownFields
	States []runtime.RawExtension `json:"states"`

	// Workflow version
	Version string `json:"version"`
}

// +kubebuilder:pruning:PreserveUnknownFields
type WorkflowExtensionsElem runtime.RawExtension

var enumValues_CallbackstateType = []string{
	"callback",
}
var enumValues_DatabasedswitchType = []string{
	"switch",
}
var enumValues_DataconditionOperator = []string{
	"exists",
	"notexists",
	"null",
	"notnull",
	"equals",
	"notequals",
	"lessthan",
	"lessthanorequals",
	"greaterthan",
	"greaterthanorequals",
	"matches",
	"notmatches",
	"custom",
}
var enumValues_DelaystateType = []string{
	"delay",
}
var enumValues_EndKind = []string{
	"default",
	"terminate",
	"event",
}
var enumValues_EventactionsActionMode = []string{
	"sequential",
	"parallel",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Workflow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["states"]; !ok || v == nil {
		return fmt.Errorf("field states: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version: required")
	}
	type Plain Workflow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Workflow(plain)
	return nil
}

var enumValues_EventbasedswitchType = []string{
	"switch",
}
var enumValues_EventstateType = []string{
	"event",
}
var enumValues_ForeachstateType = []string{
	"foreach",
}
var enumValues_InjectstateType = []string{
	"inject",
}
var enumValues_OperationstateActionMode = []string{
	"sequential",
	"parallel",
}
var enumValues_OperationstateType = []string{
	"operation",
}
var enumValues_ParallelstateCompletionType = []string{
	"and",
	"xor",
	"n_of_m",
}
var enumValues_ParallelstateType = []string{
	"parallel",
}
var enumValues_StartKind = []string{
	"default",
	"scheduled",
}
var enumValues_SubflowstateType = []string{
	"subflow",
}
